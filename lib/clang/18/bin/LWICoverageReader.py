#!/usr/bin/env python3
"""Utility script for printing and merging LWI code coverage information

Usage examples:

./LWICoverageReader.py --fingerprint-file <fingerprint-file> <coverage_file-1> [<coverage_file-2> ...]

Prints the code coverage report. Code coverage data is taken from all the code
coverage files.

./LWICoverageReader.py <coverage_file-1> [<coverage_file-2> ...] --merge-output [<coverage_merged_file>]

Merges the code coverage data and writes it to <coverage_merged_file>.
If <coverage_merged_file> is not provided, then writes to
'cov_merged.data' file.

./LWICoverageReader.py --fingerprint-file <fingerprint-file> <coverage_file-1> [<coverage_file-2> ...] --merge-output [<coverage_merged_file>]

Prints the code coverage report, and writes the merged code coverage data.
"""
'''===------ LWICoverageReader.py-----------------------------------------------===
   (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.

  ===----------------------------------------------------------------------='''

import argparse
import logging
import os
import sys
import struct
from LWIReader import LWIReader
from pathlib import Path
import fnmatch


def initialize_parser():
    parser = argparse.ArgumentParser(
        description="Print and merge LWI code coverage information.")
    parser.add_argument('--fingerprint-file',
                        dest='fingerprint_file',
                        help='LWI fingerprint database')
    parser.add_argument(
        'coverage_files',
        nargs='+',
        help="Coverage files generated by LWI code coverage functionality.")
    # Add brief option instead!
    parser.add_argument(
        '--strip-prefix',
        dest='strip_prefix',
        metavar='GLOB_STYLE_PATTERN',
        help=(
            'If specified, file paths in the coverage output will be stripped '
            'if they are prefixed with the GLOB_STYLE_PATTERN. '
            'GLOB_STYLE_PATTERN is a glob-style pattern.'))
    parser.add_argument('--show-unused-functions',
                        dest='show_unused_functions',
                        action='store_true',
                        help="Show all unused functions")

    parser.add_argument('--show-used-functions',
                        dest='show_used_functions',
                        action='store_true',
                        help="Show all used functions")

    parser.add_argument('--merge-output',
                        dest='merge_output',
                        help=("File to store merged coverage data."))
    return parser


def process_and_validate_args(parser):
    """Process and validate arguments.

    It verifies that all the passed files exists, and sets meaningful
    default value for args.default.
    """
    args = parser.parse_args()
    files = [args.fingerprint_file, *args.coverage_files]
    for file in files:
        if file and not os.path.isfile(file):
            parser.exit(1, "'{}' not found!".format(file))
    args.default = (not args.show_unused_functions
                    and not args.show_used_functions)
    return args


def remove_prefix(s, prefix):
    """Remove the prefix 'prefix', if any, from the string 's'."""
    prefix = prefix.rstrip(r'\/')
    source_path = Path(s)
    for parent in source_path.parents:
        if fnmatch.fnmatchcase(str(parent), prefix):
            return str(source_path.relative_to(parent))
    return s


class LWICoverageReader(object):
    """LWICoverageReader is responsible for the main functionality of reading
    code coverage data and creating code coverage information."""

    def __init__(self, coverage_files, lwi_file):
        self.coverage_files = coverage_files
        self.lwi_file = lwi_file
        self.lwi_info = None
        self.all_fingerprints = None
        self.covered_fingerprints = None
        self.checksum = None
        self.use_indexes = False
        self.flags = 0
        if self.lwi_file:
            self.read_fingerprint_db()

    # LWI magic bytes: "LWI\0"
    LWI_COV_MAGIC_BYTES = b'\x4c\x57\x49\x00'
    LWI_VERSION = 1
    LWI_COV_HEADER_FORMAT = '<4sIII'

    def read_fingerprint_db(self):
        """Read LWI fingerprint file."""
        self.lwi_info = LWIReader(self.lwi_file)
        # Read LWI data
        if self.lwi_info.bad():
            raise ValueError('Failed to initialize LWI reader.')
        try:
            self.lwi_info.readLWIInfo()
        except Exception as E:
            raise ValueError("Invalid LWI data file '{0}'".format(
                self.lwi_file))
        if self.lwi_info.bad():
            raise ValueError('Failed to read LWI fingerprint database.')
        self.all_fingerprints = self.lwi_info.finger_prints

    def read_lwi_coverage_file(self, coverage_file):
        """Read LWI coverage data from coverage_file, and returns a set of
        covered fingerprints."""
        covered_fingerprints = set()
        with open(coverage_file, 'rb') as f:
            (magic, version, flags,
             checksum) = struct.unpack(LWICoverageReader.LWI_COV_HEADER_FORMAT,
                                       f.read(16))
            if magic != LWICoverageReader.LWI_COV_MAGIC_BYTES or \
                    version != LWICoverageReader.LWI_VERSION:
                raise ValueError(
                    "coverage data file, '{0}', does not have a correct header."
                    .format(coverage_file))
            if flags & 1:
                self.flags |= flags
                logging.warning(
                    "coverage data in the file, '%s', is incomplete due to insufficient buffer."
                )
            if flags & 2:
                self.use_indexes = True
            if self.checksum is None:
                self.checksum = checksum
                self.module = self.lwi_info.lwi_modules_by_checksum.get(
                    checksum)
                if not self.module:
                    logging.warning((
                        'module checksum in the coverage file '
                        'does not match any module in the fingerprint database'
                    ))
                    if self.use_indexes:
                        raise ValueError(
                            ('module checksum in the coverage file must '
                             'match a module in the fingerprint database'
                             'to report bitmap-based coverage'))
            if checksum != self.checksum:
                raise ValueError(
                    ("Mismatch found in program checkum attribute in "
                     "the LWI coverage data files. All LWI data "
                     "coverage files should have the same program "
                     "checksum"))
            while 1:
                data = f.read(4)
                if not data:
                    break
                probe_id = int.from_bytes(data, byteorder='little')
                if self.use_indexes:
                    try:
                        fingerprint = self.module.index_map[probe_id]
                    except:
                        logging.warning('cannot map index {probe_id}'.format(
                            probe_id=probe_id))
                        continue
                else:
                    fingerprint = probe_id
                covered_fingerprints.add(fingerprint)
        return covered_fingerprints

    def read_coverage_data(self):
        """Read all coverage data files. Returns true if reading is
        successful"""
        covered_fingerprints = set()
        for coverage_file in self.coverage_files:
            covered_fingerprints_for_file = self.read_lwi_coverage_file(
                coverage_file)
            if covered_fingerprints_for_file == False:
                return False
            covered_fingerprints |= covered_fingerprints_for_file
        self.covered_fingerprints = covered_fingerprints
        return True

    def create_coverage_info(self, strip_prefix):
        """Create code coverage information using LWI fingerprint database, and
        the covered fingerprints."""
        assert self.all_fingerprints, "fingerprint database is not initialized"
        coverage_info = {}
        for fingerprint in self.all_fingerprints:
            if not fingerprint.source():
                continue
            source = fingerprint.source()
            if strip_prefix:
                source = remove_prefix(source, strip_prefix)
            if source not in coverage_info:
                coverage_info[source] = set()
            coverage_info[source].add(
                (fingerprint.note(), fingerprint.fingerprint
                 in self.covered_fingerprints))
        self.coverage_info = coverage_info

    def write_coverage_data(covered_fingerprints, flags, program_checksum,
                            output_file):
        """Create a new LWI code coverage data file with fingerprints
        specified in covered_fingerprints. Returns true if writing coverage
        data is successful."""
        with open(output_file, 'wb') as f:
            header = struct.pack(LWICoverageReader.LWI_COV_HEADER_FORMAT,
                                 LWICoverageReader.LWI_COV_MAGIC_BYTES,
                                 LWICoverageReader.LWI_VERSION, flags,
                                 program_checksum)
            f.write(header)
            for fingerprint in covered_fingerprints:
                f.write(struct.pack('<I', fingerprint))
        return True


class GenerateCoverageReport(object):
    """Utility class for generating code coverage reports in different
    styles and formats."""
    SPACES = " " * 4

    def __init__(self, coverage_info):
        self.coverage_info = coverage_info

    def show_default_coverage_output(self):
        print("Coverage report:")
        total_fns_overall = 0
        covered_fns_overall = 0
        for file in self.coverage_info:
            print(file + ':')
            total_fns = len(self.coverage_info[file])
            covered_fns = 0
            for fn, covered in sorted(self.coverage_info[file]):
                print(('+' if covered else ' ') +
                      GenerateCoverageReport.SPACES + fn)
                if covered:
                    covered_fns += 1
            print("File coverage percentage:", covered_fns / total_fns * 100)
            total_fns_overall += total_fns
            covered_fns_overall += covered_fns
        print("Overall coverage percentage:",
              covered_fns_overall / total_fns_overall * 100)

    def show_used_or_unused_functions(self, used):
        for file in self.coverage_info:
            print(file + ':')
            text = ""
            for fn, covered in sorted(self.coverage_info[file]):
                if covered == used:
                    print('{spaces}{fn}'.format(
                        spaces=GenerateCoverageReport.SPACES, fn=fn))


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    parser = initialize_parser()
    args = process_and_validate_args(parser)
    coverage_files = args.coverage_files
    fingerprint_file = args.fingerprint_file

    try:
        lwi_coverage_reader = LWICoverageReader(coverage_files,
                                                fingerprint_file)
        logging.info("LWI code coverage files: %s", str(coverage_files))
        lwi_coverage_reader.read_coverage_data()
    except Exception as E:
        print(E)
        sys.exit(1)

    if args.merge_output:
        if not LWICoverageReader.write_coverage_data(
                lwi_coverage_reader.covered_fingerprints,
                lwi_coverage_reader.flags, lwi_coverage_reader.checksum,
                args.merge_output):
            sys.exit(2)
    if fingerprint_file:
        logging.info('LWI fingerprint database file: %s', fingerprint_file)
        try:
            lwi_coverage_reader.create_coverage_info(args.strip_prefix)
        except Exception as E:
            print(E)
            sys.exit(3)
    gen_cov_report = GenerateCoverageReport(lwi_coverage_reader.coverage_info)

    # print coverage information
    if args.default:
        gen_cov_report.show_default_coverage_output()

    # show unused functions
    if args.show_unused_functions:
        print("Unused functions:")
        gen_cov_report.show_used_or_unused_functions(used=False)

    # show used functions
    if args.show_used_functions:
        print("Used functions:")
        gen_cov_report.show_used_or_unused_functions(used=True)
